Function hashToEllipticCurvePoint(hv):
    fieldPrime <- 2 ** 256 - 2 ** 32 - 977
    curveCoefficientA <- 0
    curveCoefficientB <- 7
    hashValue <- hash(hv)
    bufferHashValue <- []
    for i <- 0 to hashValue.length by 2:
        byteStr <- hashValue.substring(i, i + 2)
        byte <- parseInt(byteStr, 16)
        bufferHashValue.push(byte)
    x <- hv
    ySquare <- (x ** 3 + curveCoefficientA * x + curveCoefficientB) % fieldPrime
    base <- ySquare
    exponent <- (fieldPrime+1)/4
    modulus <- fieldPrime
    if (modulus == 1):
            return 0
    result <- 1
    base <- base % modulus
    while exponent > 0:
        if exponent % 2 == 1:
            result <- (result * base) % modulus
        exponent <- exponent // 2
        base <- (base ** 2) % modulus
    y <- result
    if ((y ** 2) % fieldPrime != ySquare):
        throw new Error("Invalid point")
    ecPoint <- new ECPoint(x, y)
    pointX <- ecPoint.x
    pointY <- ecPoint.y
    while not (y ** 2) % fieldPrime == (x ** 3 + curveCoefficientA * x + curveCoefficientB) % fieldPrime:
        hexString <- ''
        for i <- 0 to bufferHashValue.length - 1:
            byteHex <- bufferHashValue[i].toString(16)
            if byteHex.length == 1:
                hexString += '0'
            hexString += byteHex
        bufferHashValue <- hash(hexString)
        result <- 0
        for i <- 0 to bufferHashValue.length - 1:
            result <- (result << 8) + bufferHashValue[i]
        x <- result
        ySquare <- (x ** 3 + curveCoefficientA * x + curveCoefficientB) % fieldPrime
        base <- ySquare
        exponent <- (fieldPrime+1)/4
        modulus <- fieldPrime
        if (modulus == 1):
                return 0
        result <- 1
        base <- base % modulus
        while exponent > 0:
            if exponent % 2 == 1:
                result <- (result * base) % modulus
            exponent <- exponent // 2
            base <- (base ** 2) % modulus
        y <- result
        if ((y ** 2) % fieldPrime != ySquare):
            throw new Error("Invalid point")
        ecPoint <- new ECPoint(x, y)
    return ecPoint.x
End Function


------------------------------------------------------------------------------------------

Function ecPointExponentiation(sp, exp):
    fieldPrime <- 2^256 - 2^32 - 977
    curveCoefficientA <- 0
    curveCoefficientB <- 7
    basePointX <- 55066263022277343669578718895168534326250603453777594175500187360389116729240
    basePointY <- 32670510020758816978083085130507043184471273380659243275938904335757337482424
    startPoint <- sp
    exponent <- exp
    P <- { x: startPoint, y: sqrt((startPoint^3 + curveCoefficientA * startPoint + curveCoefficientB) % fieldPrime) }
    Q <- { x: basePointX, y: basePointY }
    R <- P
    modInverse <- 0
    while exponent > 0:
        if exponent % 2 == 1:
            diffX <- Q.x - R.x
            mod <- fieldPrime
            x, y <- 1, 0
            while diffX != 0:
                quotient <- mod / diffX
                diffX, mod <- mod % diffX, diffX
                x, y <- y, x - quotient * y
            if mod == 1:
                if x < 0:
                    modInverse <- x + fieldPrime
                else:
                    modInverse <- x
            else:
                throw new Error(diffX + " has no inverse modulo " + fieldPrime)
            s <- (Q.y - R.y) * modInverse
            newX <- (s^2 - R.x - Q.x) % fieldPrime
            newY <- (-R.y + s * (R.x - newX)) % fieldPrime
            Q <- { x: newX, y: newY }
        diffX <- R.x - P.x
        mod <- fieldPrime
        x, y <- 1, 0
        while diffX != 0:
            quotient <- mod / diffX
            diffX, mod <- mod % diffX, diffX
            x, y <- y, x - quotient * y
        if mod == 1:
            if x < 0:
                modInverse <- x + fieldPrime
            else:
                modInverse <- x
        else:
            throw new Error(diffX + " has no inverse modulo " + fieldPrime)
        s <- (R.y - P.y) * modInverse
        newX <- (s^2 - P.x - R.x) % fieldPrime
        newY <- (-P.y + s * (P.x - newX)) % fieldPrime
        R <- { x: newX, y: newY }
        exponent <- exponent / 2
    return Q.x
End Function


------------------------------------------------------------------------------------------

Function ecInverse(Cr):
    n <- 115792089237316195423570985008687907852837564279074904382605163141518161494337
    base <- Cr;
    exponent <- n - 2n
    modulus <- n
    if (modulus == 1n) {
        return 0n;
    }   
    modPow <- 1n;
    base <- base % modulus;
    while (exponent > 0) {
      if (exponent % 2n == 1n) {
        modPow <- (modPow * base) % modulus;
      }
      exponent <- exponent >> 1n;
      base <- (base * base) % modulus;
    }
    keyInv <- base % n == 0n ? 0n : modPow;
    return keyInv;
End Function